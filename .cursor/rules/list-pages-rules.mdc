# NestJS Liste SayfalarÄ± - Cursor AI KurallarÄ±

Bu dosya NestJS projelerinde liste sayfalarÄ± geliÅŸtirirken Cursor AI'Ä±n takip etmesi gereken Ã¶zel kurallarÄ± iÃ§erir.

## ðŸ—ï¸ Liste SayfasÄ± Mimarisi

### Frontend YapÄ±sÄ± (Next.js)
```
module/
â”œâ”€â”€ page.tsx                 # Ana liste sayfasÄ±
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ ContentArea.tsx      # Ana iÃ§erik alanÄ±
â”‚   â”œâ”€â”€ QuickStats.tsx       # HÄ±zlÄ± istatistikler
â”‚   â”œâ”€â”€ SearchAndFilters.tsx # Arama ve filtreler
â”‚   â””â”€â”€ PageHeader.tsx       # Sayfa baÅŸlÄ±ÄŸÄ±
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ useModuleData.ts     # Veri yÃ¶netimi
â”‚   â”œâ”€â”€ useModuleUI.ts       # UI state yÃ¶netimi
â”‚   â””â”€â”€ useModulePageViewModel.ts # MVVM pattern
â”œâ”€â”€ types/
â”‚   â””â”€â”€ index.ts             # TypeScript tipleri
â””â”€â”€ utils/
    â””â”€â”€ moduleStats.ts       # Ä°statistik hesaplamalarÄ±
```

### Backend YapÄ±sÄ± (NestJS)
```
module/
â”œâ”€â”€ module.controller.ts     # REST endpoints
â”œâ”€â”€ module.service.ts        # Business logic
â”œâ”€â”€ dto/
â”‚   â”œâ”€â”€ create-module.dto.ts
â”‚   â”œâ”€â”€ update-module.dto.ts
â”‚   â”œâ”€â”€ filter-module.dto.ts # Filtreleme parametreleri
â”‚   â””â”€â”€ paginated-response.dto.ts
â”œâ”€â”€ entities/
â”‚   â””â”€â”€ module.entity.ts
â””â”€â”€ interfaces/
    â””â”€â”€ module.interface.ts
```

## ðŸ“‹ Liste SayfasÄ± Gereksinimleri

### 1. Pagination (Sayfalama)
```typescript
// DTO for pagination
export class PaginationDto {
  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  page?: number = 1;

  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  @Max(100)
  limit?: number = 20;
}

// Response interface
export interface PaginatedResponse<T> {
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}
```

### 2. Filtering (Filtreleme)
```typescript
// Filter DTO
export class FilterModuleDto extends PaginationDto {
  @IsOptional()
  @IsString()
  search?: string;

  @IsOptional()
  @IsEnum(ModuleStatus)
  status?: ModuleStatus;

  @IsOptional()
  @IsDateString()
  startDate?: string;

  @IsOptional()
  @IsDateString()
  endDate?: string;

  @IsOptional()
  @IsString()
  sortBy?: string = 'createdAt';

  @IsOptional()
  @IsEnum(['ASC', 'DESC'])
  sortOrder?: 'ASC' | 'DESC' = 'DESC';
}
```

### 3. Sorting (SÄ±ralama)
```typescript
// Sorting configuration
export interface SortConfig {
  field: string;
  direction: 'ASC' | 'DESC';
}

// Allowed sort fields
export const ALLOWED_SORT_FIELDS = [
  'id',
  'name',
  'status',
  'createdAt',
  'updatedAt'
] as const;
```

## ðŸŽ¯ Controller Pattern

```typescript
@Controller('modules')
export class ModuleController {
  constructor(private readonly moduleService: ModuleService) {}

  @Get()
  @ApiOperation({ summary: 'Liste sayfasÄ± iÃ§in modÃ¼lleri getir' })
  @ApiQuery({ name: 'page', required: false, type: Number })
  @ApiQuery({ name: 'limit', required: false, type: Number })
  @ApiQuery({ name: 'search', required: false, type: String })
  @ApiQuery({ name: 'status', required: false, enum: ModuleStatus })
  @ApiQuery({ name: 'sortBy', required: false, type: String })
  @ApiQuery({ name: 'sortOrder', required: false, enum: ['ASC', 'DESC'] })
  async findAll(
    @Query() filterDto: FilterModuleDto
  ): Promise<PaginatedResponse<Module>> {
    return this.moduleService.findAllPaginated(filterDto);
  }

  @Get('stats')
  @ApiOperation({ summary: 'Liste sayfasÄ± istatistikleri' })
  async getStats(): Promise<ModuleStats> {
    return this.moduleService.getStats();
  }

  @Get('quick-stats')
  @ApiOperation({ summary: 'HÄ±zlÄ± istatistikler' })
  async getQuickStats(): Promise<QuickStat[]> {
    return this.moduleService.getQuickStats();
  }
}
```

## ðŸ”§ Service Pattern

```typescript
@Injectable()
export class ModuleService {
  constructor(
    @InjectRepository(Module)
    private moduleRepository: Repository<Module>
  ) {}

  async findAllPaginated(filterDto: FilterModuleDto): Promise<PaginatedResponse<Module>> {
    const { page, limit, search, status, sortBy, sortOrder, startDate, endDate } = filterDto;
    
    const queryBuilder = this.moduleRepository.createQueryBuilder('module');
    
    // Search functionality
    if (search) {
      queryBuilder.andWhere(
        '(module.name ILIKE :search OR module.description ILIKE :search)',
        { search: `%${search}%` }
      );
    }
    
    // Status filter
    if (status) {
      queryBuilder.andWhere('module.status = :status', { status });
    }
    
    // Date range filter
    if (startDate) {
      queryBuilder.andWhere('module.createdAt >= :startDate', { startDate });
    }
    if (endDate) {
      queryBuilder.andWhere('module.createdAt <= :endDate', { endDate });
    }
    
    // Sorting
    if (ALLOWED_SORT_FIELDS.includes(sortBy as any)) {
      queryBuilder.orderBy(`module.${sortBy}`, sortOrder);
    }
    
    // Pagination
    const offset = (page - 1) * limit;
    queryBuilder.skip(offset).take(limit);
    
    const [data, total] = await queryBuilder.getManyAndCount();
    
    return {
      data,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
        hasNext: page * limit < total,
        hasPrev: page > 1
      }
    };
  }

  async getStats(): Promise<ModuleStats> {
    const total = await this.moduleRepository.count();
    const active = await this.moduleRepository.count({ where: { status: ModuleStatus.ACTIVE } });
    const inactive = await this.moduleRepository.count({ where: { status: ModuleStatus.INACTIVE } });
    
    return {
      total,
      active,
      inactive,
      activePercentage: total > 0 ? Math.round((active / total) * 100) : 0
    };
  }
}
```

## ðŸŽ¨ Frontend Hooks Pattern

```typescript
// Data management hook
export function useModuleData() {
  const [data, setData] = useState<Module[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [pagination, setPagination] = useState({
    page: 1,
    limit: 20,
    total: 0,
    totalPages: 0
  });
  
  const fetchData = useCallback(async (filters: FilterParams) => {
    setLoading(true);
    try {
      const response = await moduleService.getList(filters);
      setData(response.data);
      setPagination(response.pagination);
      setError(null);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, []);
  
  return {
    data,
    loading,
    error,
    pagination,
    fetchData,
    refetch: () => fetchData({})
  };
}

// UI state management hook
export function useModuleUI() {
  const [filters, setFilters] = useState<FilterParams>({});
  const [selectedItems, setSelectedItems] = useState<Module[]>([]);
  const [viewMode, setViewMode] = useState<'table' | 'grid'>('table');
  const [sortConfig, setSortConfig] = useState<SortConfig>({
    field: 'createdAt',
    direction: 'DESC'
  });
  
  const updateFilter = useCallback((key: string, value: any) => {
    setFilters(prev => ({ ...prev, [key]: value }));
  }, []);
  
  const resetFilters = useCallback(() => {
    setFilters({});
  }, []);
  
  return {
    filters,
    selectedItems,
    viewMode,
    sortConfig,
    updateFilter,
    resetFilters,
    setSelectedItems,
    setViewMode,
    setSortConfig
  };
}
```

## ðŸ“Š Ä°statistik HesaplamalarÄ±

```typescript
// utils/moduleStats.ts
export const calculateModuleStats = (modules: Module[]) => {
  const total = modules.length;
  const byStatus = modules.reduce((acc, module) => {
    acc[module.status] = (acc[module.status] || 0) + 1;
    return acc;
  }, {} as Record<ModuleStatus, number>);
  
  return {
    total,
    byStatus,
    activePercentage: total > 0 ? Math.round((byStatus.ACTIVE / total) * 100) : 0
  };
};

export const generateQuickStats = (modules: Module[]): QuickStat[] => {
  const stats = calculateModuleStats(modules);
  
  return [
    {
      label: 'Toplam ModÃ¼l',
      value: stats.total,
      change: '+5%',
      trend: 'up',
      color: 'blue',
      icon: 'Package'
    },
    {
      label: 'Aktif ModÃ¼ller',
      value: stats.byStatus.ACTIVE || 0,
      change: '+12%',
      trend: 'up',
      color: 'green',
      icon: 'CheckCircle'
    }
  ];
};
```

## ðŸ” Arama ve Filtreleme KurallarÄ±

1. **Arama (Search)**:
   - Minimum 2 karakter
   - Debounce 300ms
   - Birden fazla alanda arama (name, description)
   - Case-insensitive

2. **Filtreler**:
   - Enum deÄŸerleri iÃ§in dropdown
   - Tarih aralÄ±ÄŸÄ± iÃ§in date picker
   - Boolean deÄŸerler iÃ§in checkbox
   - Ã‡oklu seÃ§im iÃ§in multi-select

3. **SÄ±ralama**:
   - Sadece izin verilen alanlar
   - ASC/DESC desteÄŸi
   - VarsayÄ±lan: createdAt DESC

## ðŸŽ¯ Performans OptimizasyonlarÄ±

1. **Database**:
   - Index'ler: search alanlarÄ±, foreign key'ler, sÄ±ralama alanlarÄ±
   - Query optimization
   - Connection pooling

2. **Frontend**:
   - React.memo() kullanÄ±mÄ±
   - useMemo() ve useCallback() hooks
   - Virtual scrolling (bÃ¼yÃ¼k listeler iÃ§in)
   - Lazy loading

3. **Caching**:
   - Redis cache
   - Query result caching
   - Static data caching

## ðŸ§ª Test KurallarÄ±

```typescript
// Controller test
describe('ModuleController', () => {
  it('should return paginated modules', async () => {
    const result = await controller.findAll({
      page: 1,
      limit: 10,
      search: 'test'
    });
    
    expect(result.data).toBeDefined();
    expect(result.pagination.page).toBe(1);
    expect(result.pagination.limit).toBe(10);
  });
});

// Service test
describe('ModuleService', () => {
  it('should filter modules by status', async () => {
    const result = await service.findAllPaginated({
      status: ModuleStatus.ACTIVE
    });
    
    expect(result.data.every(m => m.status === ModuleStatus.ACTIVE)).toBe(true);
  });
});
```

## ðŸ”’ GÃ¼venlik KurallarÄ±

1. **Input Validation**:
   - DTO validation
   - SQL injection korumasÄ±
   - XSS korumasÄ±

2. **Authorization**:
   - Role-based access
   - Resource-level permissions
   - Rate limiting

3. **Data Sanitization**:
   - Input sanitization
   - Output encoding
   - File upload validation

## ðŸ“± Responsive Design

1. **Mobile First**:
   - KÃ¼Ã§Ã¼k ekranlar iÃ§in optimize
   - Touch-friendly interface
   - Swipe gestures

2. **Adaptive Layout**:
   - Grid/List view toggle
   - Collapsible filters
   - Sticky headers

## ðŸŽ¨ UI/UX KurallarÄ±

1. **Loading States**:
   - Skeleton loading
   - Progress indicators
   - Error boundaries

2. **Empty States**:
   - Meaningful messages
   - Action suggestions
   - Illustration/icons

3. **Accessibility**:
   - ARIA labels
   - Keyboard navigation
   - Screen reader support

---

**Not**: Bu kurallar NinetyNine Admin Web projesinin mevcut mimarisine uygun olarak hazÄ±rlanmÄ±ÅŸtÄ±r. Yeni liste sayfalarÄ± oluÅŸtururken bu pattern'leri takip edin.